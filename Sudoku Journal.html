<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Journal</title>
<link rel="manifest" href="manifest.json">

    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'IBM Plex Mono', monospace; }
        table { border-collapse: collapse; margin: 20px auto; }
        table, td { border: 1px solid black; }
        td { width: 40px; height: 40px; text-align: center; font-size: 26px; }
        input { width: 100%; height: 100%; text-align: center; font-size: 26px; }
        #log { width: 90%; margin: 20px auto; text-align: center; }
        #log div { margin: 5px 0; }
        #button-container { text-align: center; margin-bottom: 20px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
    <h1 style="text-align: center;">Sudoku Journal</h1>



    <div id="button-container">
        <button id="startButton" onclick="startLogging()">Start Logging</button>
        <button id="stopButton" onclick="stopLogging()" style="display: none;">Stop Logging</button>
        <button id="resetButton" onclick="resetGame()" style="display: inline;">Reset</button>
    </div>

    <table>
        <tbody id="sudoku-grid">
            <!-- Rows and cells will be generated here by JavaScript -->
        </tbody>
    </table>

    <div id="log">
        <h2>Move Log:</h2>
        <!-- Logs will appear here -->
    </div>

    <div id="download-container" style="text-align: center; margin-top: 20px;">
        <button id="downloadCSVButton" onclick="downloadCSV()">Download Log (CSV)</button>
        <button id="downloadTXTButton" onclick="downloadTXT()">Download Log (TXT)</button>
        <button id="downloadPDFButton" onclick="downloadPDF()">Download Log (PDF)</button>
    </div>

<script>
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js')
            .then((registration) => {
                console.log('Service Worker registered with scope:', registration.scope);
            })
            .catch((error) => {
                console.log('Service Worker registration failed:', error);
            });
    });
}
</script>


    <script>
        let loggingEnabled = false;
        let startTime = null;
        let totalElapsedTime = 0;
        let logCount = 0;
        let lastInputTime = null;

        function startLogging() {
            if (!loggingEnabled) {
                loggingEnabled = true;
                startTime = new Date().getTime();
                document.getElementById("startButton").style.display = "none";
                document.getElementById("stopButton").style.display = "inline";

                // Disable inputs for pre-filled puzzle numbers
                const inputs = document.querySelectorAll("#sudoku-grid input");
                inputs.forEach(input => {
                    if (input.value !== '') {
                        input.setAttribute("readonly", true); // Make pre-filled cells readonly
                        input.style.backgroundColor = "#f0f0f0"; // Optional: Lighten background for clarity
                    }
                });

                alert("Logging started! Enter your moves.");
            }
        }

        function stopLogging() {
            if (loggingEnabled) {
                loggingEnabled = false;
                const currentTime = new Date().getTime();
                totalElapsedTime += Math.floor((currentTime - startTime) / 1000);
                document.getElementById("startButton").style.display = "inline";
                document.getElementById("stopButton").style.display = "none";
                alert("Logging stopped!");
                lastInputTime = null;
            }
        }

        function resetGame() {
            const inputs = document.querySelectorAll("#sudoku-grid input");
            inputs.forEach(input => {
                input.value = '';
                input.removeAttribute("readonly"); // Make all cells editable again
                input.style.backgroundColor = ""; // Reset background color
            });
            const logContainer = document.getElementById("log");
            logContainer.innerHTML = '<h2>Move Log:</h2>';
            loggingEnabled = false;
            startTime = null;
            totalElapsedTime = 0;
            logCount = 0;
            lastInputTime = null;
            document.getElementById("startButton").style.display = "inline";
            document.getElementById("stopButton").style.display = "none";
        }

        const grid = document.getElementById("sudoku-grid");
        for (let i = 0; i < 9; i++) {
            let row = document.createElement("tr");
            for (let j = 0; j < 9; j++) {
                let cell = document.createElement("td");
                let input = document.createElement("input");
                input.setAttribute("maxlength", "1");
                input.addEventListener("input", logMove);
                input.addEventListener("keydown", function(event) {
                    if (!/^[1-9]$/.test(event.key) && event.key !== 'Backspace') {
                        event.preventDefault();
                    }
                });
                cell.appendChild(input);
                row.appendChild(cell);
            }
            grid.appendChild(row);
        }

        function logMove(event) {
            if (loggingEnabled) {
                let cell = event.target.parentElement;
                let row = cell.parentElement.rowIndex;
                let col = cell.cellIndex + 1; // Keep column as 1-indexed
                let value = event.target.value;

                if (value === '') {
                    return;
                }

                logCount++;
                const currentTime = new Date().getTime();
                let timeDifference = 0;

                if (lastInputTime !== null) {
                    timeDifference = Math.floor((currentTime - lastInputTime) / 1000);
                }

                lastInputTime = currentTime;
                totalElapsedTime += Math.floor((currentTime - startTime) / 1000);

                let totalMinutes = Math.floor(totalElapsedTime / 60);
                let totalSeconds = totalElapsedTime % 60;
                let formattedTotalTime = `${String(totalMinutes).padStart(2, '0')}:${String(totalSeconds).padStart(2, '0')}`;

                let diffMinutes = Math.floor(timeDifference / 60);
                let diffSeconds = timeDifference % 60;
                let formattedDiffTime = `${String(diffMinutes).padStart(2, '0')}:${String(diffSeconds).padStart(2, '0')}`;

                // Map row index (0-8) to letters (A-I)
                let rowLetter = String.fromCharCode(row + 65); // 65 is the ASCII code for 'A'

                // Get the current timestamp
                let timestamp = new Date().toLocaleTimeString();

                let logEntry = document.createElement("div");
                logEntry.textContent = `Move ${logCount}: Cell: (${rowLetter}, ${col}), Value: ${value}, Time since last move: ${formattedDiffTime}, Total Time: ${formattedTotalTime}, Timestamp: ${timestamp}`;
                document.getElementById("log").appendChild(logEntry);

                startTime = currentTime;
            }
        }

        function downloadCSV() {
            const logEntries = document.querySelectorAll("#log div");
            if (logEntries.length === 0) {
                alert("No moves to download.");
                return;
            }

            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Move,Row,Column,Value,Time since last move,Total Time,Timestamp\n";

            logEntries.forEach((entry) => {
                const moveText = entry.textContent;
                const moveMatch = moveText.match(/Move (\d+): Cell: \((\w), (\d+)\), Value: (\d+), Time since last move: ([\d:]+), Total Time: ([\d:]+), Timestamp: (.+)/);

                if (moveMatch) {
                    const [, move, row, col, value, timeSinceLastMove, totalTime, timestamp] = moveMatch;
                    const csvRow = `${move},${row},${col},${value},${timeSinceLastMove},${totalTime},${timestamp}\n`;
                    csvContent += csvRow;
                }
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "sudoku_log.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function downloadTXT() {
            const logEntries = document.querySelectorAll("#log div");
            if (logEntries.length === 0) {
                alert("No moves to download.");
                return;
            }

            let txtContent = "Move Log:\n";
            logEntries.forEach((entry) => {
                txtContent += entry.textContent + "\n";
            });

            const blob = new Blob([txtContent], { type: "text/plain" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "sudoku_log.txt";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        async function downloadPDF() {
    const logEntries = document.querySelectorAll("#log div");
    if (logEntries.length === 0) {
        alert("No moves to download.");
        return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    doc.setFont('IBM Plex Mono');
    doc.setFontSize(12);
    doc.text("Sudoku Move Log", 10, 10);

    let yPosition = 20;
    const maxY = doc.internal.pageSize.height - 10; // Max Y position before reaching the bottom of the page

    logEntries.forEach((entry, index) => {
        const text = entry.textContent;
        const splitText = doc.splitTextToSize(text, 190); // Adjust width for the text area
        splitText.forEach(line => {
            if (yPosition > maxY) {
                doc.addPage();
                yPosition = 10; // Reset yPosition to top
            }
            doc.text(line, 10, yPosition);
            yPosition += 10; // Move down for the next line
        });
        
        // Add extra spacing after each entry
        yPosition += 5;
    });

    doc.save("sudoku_log.pdf");
}

    </script>
</body>
</html>
