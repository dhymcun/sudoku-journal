<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Journal</title>

    <link rel="manifest" href="manifest.json">
    <script>
       if ('serviceWorker' in navigator) {
           window.addEventListener('load', () => {
               navigator.serviceWorker.register('service-worker.js')
               .then((registration) => {
                   console.log('Service Worker registered with scope:', registration.scope);
               })
               .catch((error) => {
                   console.log('Service Worker registration failed:', error);
               });
           });
       }
    </script>

    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'IBM Plex Mono', monospace; }
        table { border-collapse: collapse; margin: 20px auto; }
        table, td { border: 1px solid black; }
        td { width: 40px; height: 40px; text-align: center; font-size: 26px; }
        input { width: 100%; height: 100%; text-align: center; font-size: 26px; }
        #log { width: 90%; margin: 20px auto; text-align: center; }
        #log div { margin: 5px 0; }
        #button-container { text-align: center; margin-bottom: 20px; }

#header-container {
    display: flex; /* Enable Flexbox */
    flex-direction:  column; /* Stack children vertically */
    align-items: center; /* Center children horizontally */
    margin-top: 20px; /* Add some space at the top */
}

#aboutButton {
    display: inline-block; /* Use inline-block to prevent full-width behavior */
    margin: 0 auto; /* Center the button horizontally */
    background-color: #4CAF50; /* Green background */
    color: white; /* White text */
    padding: 5px 10px; /* Padding around the text */
    text-decoration: none; /* Remove underline from the link */
    border-radius: 5px; /* Rounded corners */
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); /* Optional shadow */
    font-size: 16px; /* Adjust font size */
    z-index: 10; /* Ensure it appears above other elements */
    max-width: 150px; /* Limit the maximum width */
    text-align: center; /* Center the text */
}

#instructionButton {
    background-color: #4CAF50; /* Green background */
    color: white; /* White text */
    padding: 5px 10px; /* Padding around the text */
    text-decoration: none; /* Remove underline from the link */
    border-radius: 5px; /* Rounded corners */
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3); /* Optional shadow */
    font-size: 16px; /* Adjust font size */
    z-index: 10; /* Ensure it appears above other elements */
    max-width: 150px; /* Limit the maximum width */
    text-align: center; /* Center the text */
}

#instructionButton:hover {
    background-color: #45a049; /* Darker green on hover */
}



        /* Styles for the floating number pad */

#number-pad {
    display: none;
    position: absolute;
    background-color: white;
    border: 1px solid black;
    z-index: 10;
    padding: 0; /* Ensure no padding in the number pad container */
}

#number-pad table {
    border-collapse: collapse; /* Ensure there is no extra space between the table cells */
    margin: 0;
    padding: 0;
}

#number-pad td {
    width: 40px;
    height: 40px;
    text-align: center;
    margin: 0;
    padding: 0;
    box-sizing: border-box; /* Include padding and borders in width/height */
}

#number-pad button {
    width: 100%;
    height: 100%;
    font-size: 20px;
    cursor: pointer;
    padding: 0;
    margin: 0;
    border: 0.5px solid black;
    box-sizing: border-box; /* Ensure the button size remains consistent */
    background-color: #f9f9f9;
}




/* Optional hover effect for buttons */
#number-pad button:hover {
    background-color: #e0e0e0; /* Change color on hover for visual feedback */
}

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
    <div id="header-container" style="text-align: center;">
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
            <a href="instruction.html" id="instructionButton">Instructions</a>
            <a href="about.html" id="aboutButton">About</a> <!-- New About Button -->
        </div>
        <h1 style="margin-top: 20px;">Sudoku Journal</h1>
    </div>




    <div id="button-container">
        <button id="startButton" onclick="startLogging()">Start Logging</button>
<button id="resetButton" onclick="resetGame()" style="display: none;">Reset</button>    </div>

    <table>
        <tbody id="sudoku-grid">
            <!-- Rows and cells will be generated here by JavaScript -->
        </tbody>
    </table>

 <div id="real-time-stats" style="text-align: center; margin-top: 10px; font-size: 14px;">
        <span id="amt">AMT: 00:00</span> | 
        <span id="timer">Timer: 00:00:00</span> | 
        <span id="box-count">Box: 0/81</span> | 
        <span id="current-date">Date: </span>
    </div>

    <div id="log">
        <h2>Move Log:</h2>
        <!-- Logs will appear here -->
    </div>

    <div id="download-container" style="text-align: center; margin-top: 20px;">
        <button id="downloadCSVButton" onclick="downloadCSV()">Download Log (CSV)</button>
        <button id="downloadTXTButton" onclick="downloadTXT()">Download Log (TXT)</button>
        <button id="downloadPDFButton" onclick="downloadPDF()">Download Log (PDF)</button>
<button id="downloadImageButton" onclick="downloadImage()">Download Sudoku Table</button>

    </div>

    <!-- Floating number pad -->
    <div id="number-pad">
        <table>
            <tbody>
                <tr>
                    <td><button onclick="selectNumber(1)">1</button></td>
                    <td><button onclick="selectNumber(2)">2</button></td>
                    <td><button onclick="selectNumber(3)">3</button></td>
                </tr>
                <tr>
                    <td><button onclick="selectNumber(4)">4</button></td>
                    <td><button onclick="selectNumber(5)">5</button></td>
                    <td><button onclick="selectNumber(6)">6</button></td>
                </tr>
                <tr>
                    <td><button onclick="selectNumber(7)">7</button></td>
                    <td><button onclick="selectNumber(8)">8</button></td>
                    <td><button onclick="selectNumber(9)">9</button></td>
                </tr>
            </tbody>
        </table>
    </div>

<canvas id="sudokuCanvas" style="display: none;"></canvas>


    <script>
    let loggingEnabled = false;
    let startTime = null;
    let totalElapsedTime = 0;
    let logCount = 0;
    let lastInputTime = null;
    let selectedCell = null; // To keep track of which cell was clicked
  let filledCells = 0;
        let timerInterval;

  function updateStats() {
    if (loggingEnabled) {
        const currentTime = new Date().getTime();
        const elapsedTime = Math.floor((currentTime - startTime) / 1000); // Calculate elapsed time in seconds

        // Timer Calculation
        const hours = Math.floor(elapsedTime / 3600);
        const minutes = Math.floor((elapsedTime % 3600) / 60);
        const seconds = elapsedTime % 60;
        document.getElementById('timer').textContent = `Timer: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

        // Average Move Time (AMT)
        const avgMoveTime = logCount ? Math.floor(elapsedTime / logCount) : 0;
        document.getElementById('amt').textContent = `AMT: ${String(Math.floor(avgMoveTime / 60)).padStart(2, '0')}:${String(avgMoveTime % 60).padStart(2, '0')}`;

        // Update Box Count
        updateBoxCount();

        // Current Date
        const today = new Date().toLocaleDateString('en-US');
        document.getElementById('current-date').textContent = `Date: ${today}`;
    }
}

function handleInputChange(event) {
    if (loggingEnabled && event.target.value !== '') {
        // Increment logCount when a number is entered
        logCount++;
        updateBoxCount(); // Call to update the box count
    }
}

// Function to update box count
function updateBoxCount() {
    const inputs = document.querySelectorAll("#sudoku-grid input");
    let filledCells = Array.from(inputs).filter(input => input.value !== '').length;
    document.getElementById('box-count').textContent = `Box: ${filledCells}/81`; // Update box count display
}

// Attach event listeners to input fields for tracking changes
const inputs = document.querySelectorAll("#sudoku-grid input");
inputs.forEach(input => {
    input.addEventListener('input', handleInputChange); // Call handleInputChange on input event
});
    

    function startLogging() {
    if (!loggingEnabled) {
        loggingEnabled = true;
        startTime = new Date().getTime(); // Start the timer
        updateStats(); // Initial update for stats
        updateBoxCount(); // Update box count at the start
        timerInterval = setInterval(updateStats, 1000); // Update every second

        // Hide start button and show reset button
        document.getElementById("startButton").style.display = "none";
        document.getElementById("resetButton").style.display = "inline";

        // Make input boxes uneditable and change background color for filled inputs
        const inputs = document.querySelectorAll("#sudoku-grid input");
        inputs.forEach(input => {
            if (input.value !== '') { // Check if the input has a value
                input.setAttribute("readonly", true); // Set readonly attribute to true
                input.style.backgroundColor = "#d3d3d3"; // Change background color to soft gray
            }
        });
    }
}




function resetGame() {
    const inputs = document.querySelectorAll("#sudoku-grid input");
    inputs.forEach(input => {
        input.value = ''; // Clear the input value
        input.removeAttribute("readonly"); // Make all cells editable again
        input.style.backgroundColor = ""; // Reset background color
    });
    
    const logContainer = document.getElementById("log");
    logContainer.innerHTML = '<h2>Move Log:</h2>'; // Clear the log

    // Reset the displayed statistics
    const today = new Date().toLocaleDateString('en-US');
    document.getElementById('amt').textContent = "AMT: 00:00"; // Reset Average Move Time
    document.getElementById('timer').textContent = "Timer: 00:00:00"; // Reset Timer
    document.getElementById('box-count').textContent = "Box: 0/81"; // Reset Box Count
    document.getElementById('current-date').textContent = `Date: ${today}`; // Reset Date

    // Reset logging state
    loggingEnabled = false; // Set logging to false
    startTime = null; // Reset start time
    totalElapsedTime = 0; // Reset total elapsed time
    logCount = 0; // Reset log count
    lastInputTime = null; // Reset last input time
    
    document.getElementById("startButton").style.display = "inline"; // Show start button again
    document.getElementById("resetButton").style.display = "none"; // Hide reset button
}



    const grid = document.getElementById("sudoku-grid");
for (let i = 0; i < 9; i++) {
    let row = document.createElement("tr");
    for (let j = 0; j < 9; j++) {
        let cell = document.createElement("td");
        let input = document.createElement("input");
        input.setAttribute("maxlength", "1");

        // Validate input to allow only numbers 1-9
        input.addEventListener("input", function (event) {
            const value = event.target.value;
            if (!/^[1-9]$/.test(value)) {
                event.target.value = ''; // Clear invalid input
            }
            logMove(event); // Call logMove to log the move
        });

        input.addEventListener("click", showNumberPad);
        cell.appendChild(input);
        row.appendChild(cell);
    }
    grid.appendChild(row);
}





    // Show the number pad when a cell is clicked
    function showNumberPad(event) {
    selectedCell = event.target;
    const numberPad = document.getElementById("number-pad");
    numberPad.style.display = "block";

    const rect = selectedCell.getBoundingClientRect();
    const padRect = numberPad.getBoundingClientRect(); // Get the size of the number pad

    let leftPos = rect.left;
    let topPos = rect.top + rect.height; // Position below the cell

    // Check if the number pad is overflowing to the right of the viewport
    if (leftPos + padRect.width > window.innerWidth) {
        leftPos = window.innerWidth - padRect.width; // Adjust to keep it inside the screen
    }

    // Check if the number pad is overflowing at the bottom of the viewport
    if (topPos + padRect.height > window.innerHeight) {
        topPos = rect.top - padRect.height; // Show it above the cell if there's no space below
    }

    numberPad.style.left = `${leftPos}px`;
    numberPad.style.top = `${topPos}px`;
}


    // Select a number from the number pad and place it in the selected cell
function selectNumber(number) {
    if (selectedCell && !selectedCell.hasAttribute("readonly")) { // Check if the cell is not readonly
        selectedCell.value = number;
        selectedCell.dispatchEvent(new Event("input")); // Log the move
    }
    hideNumberPad();
}

    // Hide the number pad
    function hideNumberPad() {
        document.getElementById("number-pad").style.display = "none";
    }

    // Close the number pad if the user clicks outside
    document.addEventListener("click", function(event) {
        const numberPad = document.getElementById("number-pad");
        if (!numberPad.contains(event.target) && !selectedCell?.contains(event.target)) {
            hideNumberPad();
        }
    });

    function logMove(event) {
    if (loggingEnabled) {
        let cell = event.target.parentElement;
        let row = cell.parentElement.rowIndex + 1; // Add 1 to make it 1-indexed
        let col = cell.cellIndex + 1; // Column is also 1-indexed
        let value = event.target.value;

        if (value === '') {
            return;
        }

        logCount++;
        const currentTime = new Date().getTime();
        let timeDifference = 0;

        if (lastInputTime !== null) {
            timeDifference = Math.floor((currentTime - lastInputTime) / 1000);
        }

        lastInputTime = currentTime;
        totalElapsedTime += timeDifference;

        // Format the total elapsed time
        const totalHours = Math.floor(totalElapsedTime / 3600);
        const totalMinutes = Math.floor((totalElapsedTime % 3600) / 60);
        const totalSeconds = totalElapsedTime % 60;
        const formattedTotalTime = `${String(totalHours).padStart(2, '0')}:${String(totalMinutes).padStart(2, '0')}:${String(totalSeconds).padStart(2, '0')}`;

        // Format the time since the last move
        const diffHours = Math.floor(timeDifference / 3600);
        const diffMinutes = Math.floor((timeDifference % 3600) / 60);
        const diffSeconds = timeDifference % 60;
        const formattedDiffTime = `${String(diffHours).padStart(2, '0')}:${String(diffMinutes).padStart(2, '0')}:${String(diffSeconds).padStart(2, '0')}`;

        // Get the current timestamp
        const timestamp = new Date().toLocaleTimeString();

        // Create log entry
        const logEntry = document.createElement("div");
        logEntry.textContent = `Move ${logCount}: Cell: (R${row}, C${col}), Value: ${value}, Time since last move: ${formattedDiffTime}, Total Time: ${formattedTotalTime}, Timestamp: ${timestamp}`;
        document.getElementById("log").appendChild(logEntry);

		updateBoxCount();

    }
}





function drawSudokuGrid() {
    const canvas = document.getElementById("sudokuCanvas");
    const ctx = canvas.getContext("2d");
    const grid = document.getElementById("sudoku-grid");
    const cellSize = 40; // Adjust this based on your table cell size

    canvas.width = cellSize * 9; // Width of the grid
    canvas.height = cellSize * 9; // Height of the grid

    // Fill the canvas with a white background
    ctx.fillStyle = "white"; // Set the fill color to white
    ctx.fillRect(0, 0, canvas.width, canvas.height); // Fill the entire canvas

    // Draw grid lines
    for (let i = 0; i <= 9; i++) {
        ctx.beginPath();
        ctx.moveTo(i * cellSize, 0);
        ctx.lineTo(i * cellSize, canvas.height);
        ctx.moveTo(0, i * cellSize);
        ctx.lineTo(canvas.width, i * cellSize);
        ctx.strokeStyle = "black";
        ctx.stroke();
    }

    // Draw numbers
    for (let i = 0; i < 9; i++) {
        for (let j = 0; j < 9; j++) {
            const input = grid.rows[i].cells[j].querySelector("input");
            const value = input.value;

            if (value) {
                ctx.font = "26px monospace"; // Same font as your table
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStyle = "black"; // Set fill style to black for the text
                ctx.fillText(value, j * cellSize + cellSize / 2, i * cellSize + cellSize / 2);
            }
        }
    }
}

function downloadImage() {
    drawSudokuGrid(); // Ensure the grid is drawn with a white background

    const canvas = document.getElementById("sudokuCanvas");
    canvas.toBlob((blob) => {
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "sudoku_table.png"; // Name of the downloaded file
        link.click();
    });
}




    function downloadCSV() {
    let csvContent = "data:text/csv;charset=utf-8,";
    csvContent += "Move,Row,Column,Value,Time since last move,Total Time,Timestamp\n";

    const logEntries = document.querySelectorAll("#log div");
    logEntries.forEach((entry) => {
        const moveMatch = entry.textContent.match(/Move (\d+): Cell: \(R(\d+), C(\d+)\), Value: (\d+), Time since last move: ([\d:]+), Total Time: ([\d:]+), Timestamp: (.+)/);

        if (moveMatch) {
            const [, move, row, col, value, timeSinceLastMove, totalTime, timestamp] = moveMatch;
            const csvRow = `${move},${row},${col},${value},${timeSinceLastMove},${totalTime},${timestamp}\n`;
            csvContent += csvRow;
        }
    });

    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", "sudoku_log.csv");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}


    function downloadTXT() {
        let txtContent = "";
        const logs = document.querySelectorAll("#log div");
        logs.forEach(log => {
            txtContent += log.textContent + "\n";
        });

        const blob = new Blob([txtContent], { type: "text/plain" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "sudoku_log.txt";
        link.click();
    }

    function downloadPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'pt', 'a4'); // Create a new jsPDF instance in portrait orientation

    doc.setFontSize(10); // Set a smaller font size (adjust as needed)

    // Add column titles
    doc.text("Move,Coordinates,Value,Time since last move,Total Time,Timestamp", 20, 30);
    
    let yPosition = 50; // Starting vertical position for log entries

    const logs = document.querySelectorAll("#log div");
    logs.forEach((log, index) => {
        const logText = log.textContent;

        // Split logText into an array of lines to manage line breaks
        const lines = doc.splitTextToSize(logText, 550); // Adjust width for text fitting

        lines.forEach((line) => {
            if (yPosition > 750) { // If yPosition exceeds 750 (adjust based on your margins)
                doc.addPage(); // Add a new page
                yPosition = 30; // Reset yPosition for new page
                doc.text("Move,Coordinates,Value,Time since last move,Total Time,Timestamp", 20, 30); // Re-add column titles
                yPosition += 20; // Leave space after titles
                doc.setFontSize(10); // Reset font size on new page
            }
            doc.text(line, 20, yPosition); // Position the text with some margin
            yPosition += 20; // Increase yPosition for next log entry
        });
    });

    doc.save("sudoku_log.pdf");
}


</script>

</body>
</html>
